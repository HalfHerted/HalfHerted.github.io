{"meta":{"title":"半心人","subtitle":"","description":"","author":"John Doe","url":"http://example.com","root":"/"},"pages":[],"posts":[{"title":"内存四区","slug":"内存四区","date":"2020-10-10T07:38:06.000Z","updated":"2020-10-10T08:18:49.524Z","comments":true,"path":"2020/10/10/内存四区/","link":"","permalink":"http://example.com/2020/10/10/%E5%86%85%E5%AD%98%E5%9B%9B%E5%8C%BA/","excerpt":"","text":"​ 这篇文章主要介绍的是程序内存的四个存储区域：代码区、全局区、栈区、堆区。 代码区​ 代码区，简单来说就是存放代码的一块区域，这块区域在程序运行前存在。其实代码区存放的代码时CPU执行的机器指令，也就是二进制字符串。 ​ 代码区有两个特点：共享性和只读性。 ​ 1、共享性：因为一个程序有可能被运行很多次，不可能每次运行前都要将代码保存一次，所以共享性是为了让程序能够高效的多次运行。 ​ 2、只读性：为了防止程序运行过程中被恶意修改代码，造成损失，所以代码区具有只读性，不能修改。 全局区​ 全局区也是在程序运行之前存在的一块区域。存放在全局区的数据主要有三类：全局变量、静态变量、常量。其中常量有可以细分为字符串常量和const修饰的变量，字符串常量存放在全局区。const修饰的变量又可以分为const修饰的全局变量和const修饰的局部变量。其中const修饰的全局变量存放在全局区，而const修饰的局部变量（局部常量）不存放在全局区。下面代码演示 12345678910111213141516171819202122232425262728293031323334#include&lt;iostream&gt;using namespace std;//全局变量int g_a = 10;int g_b = 100;//const修饰的全局变量const int c_g_a = 10;const int c_g_b = 100;int main()&#123; //静态变量 static int s_a = 100; static int s_b = 10; //const修饰的局部变量 const int c_l_a = 100; const int c_l_b = 10; //全局变量 cout &lt;&lt; &quot;全局变量g_a的地址为：&quot; &lt;&lt; &amp;g_a &lt;&lt; endl; cout &lt;&lt; &quot;全局变量g_b的地址为：&quot; &lt;&lt; &amp;g_b &lt;&lt; endl; //静态变量 cout &lt;&lt; &quot;静态变量s_a的地址为：&quot; &lt;&lt; &amp;s_a &lt;&lt; endl; cout &lt;&lt; &quot;静态变量s_a的地址为：&quot; &lt;&lt; &amp;s_a &lt;&lt; endl; //字符串常量 cout &lt;&lt; &quot;字符串常量的地址为：&quot; &lt;&lt; &amp;&quot;hello&quot; &lt;&lt; endl; //const修饰的全局变量 cout &lt;&lt; &quot;const修饰的全局变量的地址为：&quot; &lt;&lt; &amp;c_g_a &lt;&lt; endl; cout &lt;&lt; &quot;const修饰的全局变量的地址为：&quot; &lt;&lt; &amp;c_g_a &lt;&lt; endl; //const修饰的局部变量 cout &lt;&lt; &quot;const修饰的局部变量的地址为：&quot; &lt;&lt; &amp;c_l_a &lt;&lt; endl; cout &lt;&lt; &quot;const修饰的局部变量的地址为：&quot; &lt;&lt; &amp;c_l_a &lt;&lt; endl;&#125; 从运行结果可以看出全局变量、静态变量、字符串常量、以及const修饰的全局变量他们的内存位置靠得非常近，而const修饰得局部变量与他们靠得非常远。这也就说明了const修饰得局部变量与另外几个不在一个区域。 ​ 另外：全局区的数据在程序结束后由系统释放 栈区​ 栈区由编译器自动释放，存放在栈区的数据主要有函数的参数、和局部变量。尤其需要注意的是不能返回局部变量的地址，因为栈区的数据在程序结束后是由编译器自动释放，所以返回局部变量的地址是找不到你想找的那个数据的。 12345678910111213141516#include&lt;iostream&gt;using namespace std;int* test01()&#123; int a = 10; int* p = &amp;a; return p;&#125;int main()&#123; int* p = test01(); cout &lt;&lt; *p &lt;&lt; endl; //第一次成功访问到数据是因为编译器做了一次保留 cout &lt;&lt; *p &lt;&lt; endl; //第二次就访问不到该数据了&#125; 堆区​ 堆区的数据由程序员进行释放，当然如果程序员忘记释放，在程序运行结束后编译器也会帮你释放。一般在堆区开辟空间需要用到new关键字。 ​ 在上面的栈区说到不能返回局部变量的地址是因为局部变量存放在栈区，栈区的数据由编译器自动释放。那么我们把数据开辟到堆区呢？ 1234567891011121314151617#include&lt;iostream&gt;using namespace std;int* test02()&#123; int* p =new int (10); return p;&#125;int main()&#123; int* p = test02(); cout &lt;&lt; *p &lt;&lt; endl; cout &lt;&lt; *p &lt;&lt; endl; cout &lt;&lt; *p &lt;&lt; endl; cout &lt;&lt; *p &lt;&lt; endl;&#125; ​ 可以发现输出了四次仍然可以访问到数据。这是因为堆区的数据没有被释放，那么释放之后又会如何呢？ 123456789101112131415161718#include&lt;iostream&gt;using namespace std;int* test02()&#123; int* p =new int (10); return p;&#125;int main()&#123; int* p = test02(); cout &lt;&lt; *p &lt;&lt; endl; cout &lt;&lt; *p &lt;&lt; endl; free(p); cout &lt;&lt; *p &lt;&lt; endl; cout &lt;&lt; *p &lt;&lt; endl;&#125; ​ 可以看到，前两次是没有将数据释放掉是可以访问的，后面将数据释放掉之后，就访问不到该数据了。 ​ 以上就是我对内存四区的全部理解，如果有不足的地方请指正。如果觉得讲得还不错的话，可以投喂一下哦！！","categories":[],"tags":[]},{"title":"CPP提高","slug":"CPP提高","date":"2020-10-07T13:50:01.000Z","updated":"2020-10-07T14:41:33.627Z","comments":true,"path":"2020/10/07/CPP提高/","link":"","permalink":"http://example.com/2020/10/07/CPP%E6%8F%90%E9%AB%98/","excerpt":"","text":"void用法​ 对于void很多小伙伴都没有太关注过这个关键字。事实上这个关键字还是非常有用的。它可以申明一个函数没有返回值。在C语言中，void还可以写在函数的参数中，表示该函数没有参数（当然不写的话也不会报错，只不过编译器会出一个警告）。在C++中就不必将void写入函数的参数中，因为C++底层已经帮用户做了这件事情。然而void最重要的用法是void *也就是void 指针。可以说void *是所有指针的祖先。这是因为任何类型的指针都可以赋值给void *。void * 出现在函数的参数中，说明该函数可以接受任何类型的指针。如果void *出现在函数开头，说明这个函数可以返回任何类型的指针。 ​ 典型的如内存操作函数memcpy和memset的函数原型分别为：void * memcpy(void *dest, const void *src, size_t len);void * memset ( void * buffer, int c, size_t num ); 这样，任何类型的指针都可以传入memcpy和memset中，这也真实地体现了内存操作函数的意义，因为它操作的对象仅仅是一片内存，而不论这片内存是什么类型。","categories":[],"tags":[]},{"title":"vs踩过的坑","slug":"vs踩过的坑","date":"2020-10-06T14:14:01.000Z","updated":"2020-10-09T11:55:44.077Z","comments":true,"path":"2020/10/06/vs踩过的坑/","link":"","permalink":"http://example.com/2020/10/06/vs%E8%B8%A9%E8%BF%87%E7%9A%84%E5%9D%91/","excerpt":"","text":"​ 相信很多小伙伴都用过visual studio这个编译器（下文简称vs）。这款编译器的大部分功能还是很强大的，而且与其它编译器的差别并不是很明显。vs的安全性特别高，代码除了一点点的小问题，编译器就会报错。接下来就谈一谈，我使用vs过程中踩过的一些坑。 1、scanf_s​ 关于scanf函数，在很多编译器当中是可以正常使用的，但是在vs当中，它被认为是不安全函数。因为scanf函数在读取数据时不检查边界情况，这样就很懂依造成内存访问越界。vs提供了一个安全函数scanf_s(),这个函数比scanf函数多一个参数，就是你要输入的个数。在使用这个函数时，只有当要输入char【】，也就是字符数组时，才需要注意下面这些细节。 ​ 当你定义一个字符数组的长度为n时，你在输入的时候必需将你要输入的字符长度写入scanf_s的参数当中。而且，虽然你想输入n个字符，但是最多只能输入n-1个字符。因为scanf_s最后一个参数是缓冲区的大小，表示最多读取n-1个字符。下面给一些具体例子的截图。 ​ 第一张图片是正确的运行结果，第二张是当你输入的字符长度大于n-1时，此时的编译器什么也不输出。第三张是没有n-1这个参数的，编译器直接报错。如果你用scanf_s输入其他类型的变量是，是不用加n这个变量的。 ​ 以上就是scan_s函数的一些坑。（第一次写博客，写得不好的地方请多包涵，如果读者有补充的可以回帖，喜欢的可以投喂一下哦！！）","categories":[],"tags":[]},{"title":"我的第一篇博客","slug":"我的第一篇博客","date":"2020-10-02T08:06:59.000Z","updated":"2020-10-02T09:01:07.770Z","comments":true,"path":"2020/10/02/我的第一篇博客/","link":"","permalink":"http://example.com/2020/10/02/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/","excerpt":"","text":"欢迎访问我的博客（希望自己以后越来越好）","categories":[],"tags":[]}],"categories":[],"tags":[]}