<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>内存四区</title>
    <url>/2020/10/10/%E5%86%85%E5%AD%98%E5%9B%9B%E5%8C%BA/</url>
    <content><![CDATA[<p>​        这篇文章主要介绍的是程序内存的四个存储区域：代码区、全局区、栈区、堆区。</p>
<a id="more"></a>
<h4 id="代码区"><a href="#代码区" class="headerlink" title="代码区"></a>代码区</h4><p>​        代码区，简单来说就是存放代码的一块区域，这块区域在程序运行前存在。其实代码区存放的代码时CPU执行的机器指令，也就是二进制字符串。</p>
<p>​        代码区有两个特点：共享性和只读性。</p>
<p>​        1、共享性：因为一个程序有可能被运行很多次，不可能每次运行前都要将代码保存一次，所以共享性是为了让程序能够高效的多次运行。</p>
<p>​        2、只读性：为了防止程序运行过程中被恶意修改代码，造成损失，所以代码区具有只读性，不能修改。</p>
<h4 id="全局区"><a href="#全局区" class="headerlink" title="全局区"></a>全局区</h4><p>​        全局区也是在程序运行之前存在的一块区域。存放在全局区的数据主要有三类：全局变量、静态变量、常量。其中常量有可以细分为字符串常量和const修饰的变量，字符串常量存放在全局区。const修饰的变量又可以分为const修饰的全局变量和const修饰的局部变量。其中const修饰的全局变量存放在全局区，而const修饰的局部变量（局部常量）不存放在全局区。下面代码演示</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//全局变量</span></span><br><span class="line"><span class="keyword">int</span> g_a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> g_b = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//const修饰的全局变量</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> c_g_a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> c_g_b = <span class="number">100</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//静态变量</span></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> s_a = <span class="number">100</span>;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> s_b = <span class="number">10</span>;</span><br><span class="line">	<span class="comment">//const修饰的局部变量</span></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">int</span> c_l_a = <span class="number">100</span>;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">int</span> c_l_b = <span class="number">10</span>;</span><br><span class="line">	<span class="comment">//全局变量</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;全局变量g_a的地址为：&quot;</span> &lt;&lt; &amp;g_a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;全局变量g_b的地址为：&quot;</span> &lt;&lt; &amp;g_b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//静态变量</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;静态变量s_a的地址为：&quot;</span> &lt;&lt; &amp;s_a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;静态变量s_a的地址为：&quot;</span> &lt;&lt; &amp;s_a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="comment">//字符串常量</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;字符串常量的地址为：&quot;</span> &lt;&lt; &amp;<span class="string">&quot;hello&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="comment">//const修饰的全局变量</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;const修饰的全局变量的地址为：&quot;</span> &lt;&lt; &amp;c_g_a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;const修饰的全局变量的地址为：&quot;</span> &lt;&lt; &amp;c_g_a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="comment">//const修饰的局部变量</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;const修饰的局部变量的地址为：&quot;</span> &lt;&lt; &amp;c_l_a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;const修饰的局部变量的地址为：&quot;</span> &lt;&lt; &amp;c_l_a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/images/ne.png" alt="运行结果"></p>
<p>从运行结果可以看出全局变量、静态变量、字符串常量、以及const修饰的全局变量他们的内存位置靠得非常近，而const修饰得局部变量与他们靠得非常远。这也就说明了const修饰得局部变量与另外几个不在一个区域。</p>
<p>​        另外：全局区的数据在程序结束后由系统释放</p>
<h4 id="栈区"><a href="#栈区" class="headerlink" title="栈区"></a>栈区</h4><p>​        栈区由编译器自动释放，存放在栈区的数据主要有函数的参数、和局部变量。尤其需要注意的是不能返回局部变量的地址，因为栈区的数据在程序结束后是由编译器自动释放，所以返回局部变量的地址是找不到你想找的那个数据的。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="keyword">int</span>* p = &amp;a;</span><br><span class="line">	<span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span>* p = test01();</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; *p &lt;&lt; <span class="built_in">endl</span>;		<span class="comment">//第一次成功访问到数据是因为编译器做了一次保留</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; *p &lt;&lt; <span class="built_in">endl</span>;		<span class="comment">//第二次就访问不到该数据了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/images/4.png" alt="运行结果"></p>
<h4 id="堆区"><a href="#堆区" class="headerlink" title="堆区"></a>堆区</h4><p>​        堆区的数据由程序员进行释放，当然如果程序员忘记释放，在程序运行结束后编译器也会帮你释放。一般在堆区开辟空间需要用到new关键字。</p>
<p>​        在上面的栈区说到不能返回局部变量的地址是因为局部变量存放在栈区，栈区的数据由编译器自动释放。那么我们把数据开辟到堆区呢？</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span>* p =<span class="keyword">new</span> <span class="keyword">int</span> (<span class="number">10</span>);</span><br><span class="line">	<span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span>* p = test02();</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; *p &lt;&lt; <span class="built_in">endl</span>;		</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; *p &lt;&lt; <span class="built_in">endl</span>;		</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; *p &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; *p &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/images/5.png" alt="运行结果"></p>
<p>​        可以发现输出了四次仍然可以访问到数据。这是因为堆区的数据没有被释放，那么释放之后又会如何呢？</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span>* p =<span class="keyword">new</span> <span class="keyword">int</span> (<span class="number">10</span>);</span><br><span class="line">	<span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span>* p = test02();</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; *p &lt;&lt; <span class="built_in">endl</span>;		</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; *p &lt;&lt; <span class="built_in">endl</span>;		</span><br><span class="line">	<span class="built_in">free</span>(p);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; *p &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; *p &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/images/6.png" alt="运行结果"></p>
<p>​        可以看到，前两次是没有将数据释放掉是可以访问的，后面将数据释放掉之后，就访问不到该数据了。</p>
<p>​        以上就是我对内存四区的全部理解，如果有不足的地方请指正。如果觉得讲得还不错的话，可以投喂一下哦！！</p>
]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Java笔记</title>
    <url>/2020/10/22/Java%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>这篇文章是我学习Java时记录的一些笔记（将持续更新）</p>
<a id="more"></a>

<h2 id="java语言基础知识"><a href="#java语言基础知识" class="headerlink" title="java语言基础知识"></a>java语言基础知识</h2><h3 id="java主类结构"><a href="#java主类结构" class="headerlink" title="java主类结构"></a>java主类结构</h3><h4 id="定义类"><a href="#定义类" class="headerlink" title="定义类"></a>定义类</h4><p>一个Java应用程序是由若干个类组成的，在一个类中又包含了成员函数和成员变量以及局部变量。比如下面一段代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> myclass.struct;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">First</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String s1 = <span class="string">&quot;让我看看&quot;</span>; <span class="comment">//成员变量</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;	<span class="comment">//成员函数又叫主方法（main为主方法）</span></span><br><span class="line">        String s2 = <span class="string">&quot;主类的结构&quot;</span>;	<span class="comment">//局部变量</span></span><br><span class="line">        System.out.println(s1);</span><br><span class="line">        System.out.println(s2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="定义变量"><a href="#定义变量" class="headerlink" title="定义变量"></a>定义变量</h4><p>通常将类的属性称为类的全局变量或成员变量。将方法中的变量称为局部变量。全局变量申明在类体中，而局部变量申明在方法体中。</p>
<h3 id="变量与常量"><a href="#变量与常量" class="headerlink" title="变量与常量"></a>变量与常量</h3><h4 id="Java标识符"><a href="#Java标识符" class="headerlink" title="Java标识符"></a>Java标识符</h4><p>Java标识符可以由任意顺序的字母、下划线、美元符号$、和数字组成，并且第一个字符不能是数字，且不能是Java中的保留字。</p>
<h4 id="定义常量"><a href="#定义常量" class="headerlink" title="定义常量"></a>定义常量</h4><p>Java使用关键字final来声明常量，并且常量在声明之后只能初始化一次。</p>
<p>语法：final 数据类型 常量名 【= 值】</p>
<p>一般常量名都使用大写字母，这样是为了避免混淆。</p>
<p>注意：全局常量被声明之后必须马上初始化，或者在类的所有构造方法中进行初始化（这点没有理解）</p>
<h4 id="局部变量的有效范围"><a href="#局部变量的有效范围" class="headerlink" title="局部变量的有效范围"></a>局部变量的有效范围</h4><p>局部变量可以和全局变量的名字相同，此时全局变量将被隐藏，但是可以使用”this.”作为前缀来访问全局变量。</p>
<h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><h4 id="整数类型"><a href="#整数类型" class="headerlink" title="整数类型"></a>整数类型</h4><p>八进制最高位以0做区分，十六进制最高位以0X或0x做区分。Java默认的整数类型是int型，如果想定义long型整数，在定义后需要加上一个”L“。如<code>long age = 100000L;</code> </p>
<h4 id="字符类型"><a href="#字符类型" class="headerlink" title="字符类型"></a>字符类型</h4><p>char用于存储单个字符，字符类型用单引号表示，例如‘s’是一个字符而“s”是一个字符串，是因为使用双引号。</p>
<p>转义字符：\ddd 1到2位8进制数所表示的Unicode字符，如：\102 是字符B;\uXXXX 4位16进制所表示的Unicode字符，如\u0042 是字符B；</p>
<h3 id="数据类型的转换"><a href="#数据类型的转换" class="headerlink" title="数据类型的转换"></a>数据类型的转换</h3><p>数据从占用存储空间较小的类型转换位占用存储空间较大的数据类型时，不用做显示的类型转换（即自动类型转换）；反之则必须做强制类型转换。</p>
<h4 id="自动类型转换"><a href="#自动类型转换" class="headerlink" title="自动类型转换"></a>自动类型转换</h4><p>自动类型转换会发生在一下几种情况</p>
<h5 id="变量赋值"><a href="#变量赋值" class="headerlink" title="变量赋值"></a>变量赋值</h5><p>当为变量赋值的数据类型与变量类型不一样，并且赋值的数据类型级别低于变量的类型级别时，赋值数据会自动转换为变量的类型。</p>
<h5 id="方法调用"><a href="#方法调用" class="headerlink" title="方法调用"></a>方法调用</h5><p>把一个数值传递给方法的参数，并且这个数值的数据类型低于方法参数变量的数据类型。</p>
<h5 id="一元运算"><a href="#一元运算" class="headerlink" title="一元运算"></a>一元运算</h5><p>在一元运算中（除了++和-运算符），如果操作数的类型低于int类型，则操作数会自动转换为int类型。</p>
<h5 id="二元运算符"><a href="#二元运算符" class="headerlink" title="二元运算符"></a>二元运算符</h5><p>在二元运算中，所有低级的数据类型都会转换成运算中级别最高的数据类型。如果有一个操作数时double类型，其他操作数都会自动转换成double类型。</p>
<h4 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h4><p>把级别高的数据类型转换成级别低的数据类型（一定要注意数据的丢失问题）</p>
<p>语法： 数据类型  变量名 = （数据类型）变量名</p>
<p>第一个变量名是级别低的变量名，而第二个变量名是级别高的变量名</p>
<p>如：<code>long num = 9000L; short nnum = (short)num;</code> </p>
<h4 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h4><p>异或运算实现变量值的交换</p>
<p>异或运算具有一下几个特征</p>
<p>1、任意一个变量X与其自身进行异或运算，结果为0，即X^X = 0;</p>
<p>2、任意一个变量X与0进行异或运算结果为自身，即X^0 = X；</p>
<p>3、异或运算具有可结合性；</p>
<p>4、异或运算具有可交换性；</p>
<p>具体实现代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">changeAandB</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">int</span> b = <span class="number">20</span>;</span><br><span class="line">        a = a ^ b;</span><br><span class="line">        b = a ^ b;	<span class="comment">//此时a等于a^b ,b = a^b^b = a^(0) = a;</span></span><br><span class="line">        a = a ^ b;	<span class="comment">//此时b等于a ， a = a ^ b ^ a = b;</span></span><br><span class="line">        System.out.println(<span class="string">&quot;a的值是&quot;</span>+a);</span><br><span class="line">        System.out.println(<span class="string">&quot;b的值是&quot;</span>+b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>java</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>引用的用法及注意事项</title>
    <url>/2020/10/15/%E5%BC%95%E7%94%A8%E7%9A%84%E7%94%A8%E6%B3%95%E5%8F%8A%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/</url>
    <content><![CDATA[<p>​         这篇文章主要介绍一下C++中引用的一些用法和注意事项。</p>
<a id="more"></a>

<h3 id="1、引用的作用"><a href="#1、引用的作用" class="headerlink" title="1、引用的作用"></a>1、引用的作用</h3><p>​        引用在C++中的作用就是给一个变量取一个别名，具体语法为：数据类型 + &amp; + 别名 = 原名。引用的本质其实是一个指针常量。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="keyword">int</span>&amp; b = a;		<span class="comment">//a 和 b的效果相同</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	test01();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2、引用的注意事项"><a href="#2、引用的注意事项" class="headerlink" title="2、引用的注意事项"></a>2、引用的注意事项</h3><p>​        引用有两个注意需要注意的地方</p>
<h4 id="1、引用必须初始化"><a href="#1、引用必须初始化" class="headerlink" title="1、引用必须初始化"></a>1、引用必须初始化</h4><p><img src="/images/7.png" alt="引用必须初始化"></p>
<p>由图可以看到，在未初始化时，vs提示了一个错误“引用变量类型‘b’初始化设定”，这就是提示我们没有给引用初始化。</p>
<h4 id="2、引用初始化后不可改变"><a href="#2、引用初始化后不可改变" class="headerlink" title="2、引用初始化后不可改变"></a>2、引用初始化后不可改变</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="keyword">int</span> c = <span class="number">100</span>;</span><br><span class="line">	<span class="keyword">int</span>&amp; b = a;</span><br><span class="line">	b = c;		<span class="comment">//这里是赋值操作，并不能改变b的指向</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	test01();</span><br><span class="line">	system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/images/8.png" alt="引用初始化后不能改变"></p>
<p>由运行结果我们可以看出，虽然由一串代码 b=c，但这代码仅仅是赋值操作。前面我们说了，引用的本质是一个指针常量，在这里仅仅是让b所指向的内存空间（也就是a所在的内存位置）重新赋值为c（也就是100）。所以最后输出的a和b的值都为100。类似于下面代码 <code>int a = 10;int *b = &amp;a;int c = 100;*b = c;</code> 唯一不同的是*b的指向可以改变，而引用的指向不可以改变。</p>
<h3 id="3、引用作函数的参数"><a href="#3、引用作函数的参数" class="headerlink" title="3、引用作函数的参数"></a>3、引用作函数的参数</h3><p>相信大多数小伙伴都知道函数参数的传递方式有两种，第一种是值传递，第二种是地址传递。下面我们先分别为值传递和地址传递写一段代码。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//值传递</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">my_swap1</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> temp = a;</span><br><span class="line">	a = b;</span><br><span class="line">	b = temp;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;my_swap1中的a,b为&quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot;\t&quot;</span> &lt;&lt; b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">my_swap2</span><span class="params">(<span class="keyword">int</span>* a, <span class="keyword">int</span>* b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> temp = *a;</span><br><span class="line">	*a = *b;</span><br><span class="line">	*b = temp;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;my_swap2中的a,b为&quot;</span> &lt;&lt; *a &lt;&lt; <span class="string">&quot;\t&quot;</span> &lt;&lt; *b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a = <span class="number">10</span>, b = <span class="number">20</span>;</span><br><span class="line">	my_swap1(a, b);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;main中的a,b为    &quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot;\t&quot;</span> &lt;&lt; b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    my_swap1(a, b);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;main中的a,b为    &quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot;\t&quot;</span> &lt;&lt; b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/images/11.png" alt="值传递和地址传递"></p>
<p>相信大家对上面两个已经非常熟悉了，这里我就不做过多的介绍了。下面我们来看一下引用作为函数参数的情况。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">my_swap</span><span class="params">(<span class="keyword">int</span> &amp;a, <span class="keyword">int</span> &amp;b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> temp = a;</span><br><span class="line">	a = b;</span><br><span class="line">	b = temp;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;my_swap1中的a,b为&quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot;\t&quot;</span> &lt;&lt; b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a = <span class="number">10</span>, b = <span class="number">20</span>;</span><br><span class="line">	my_swap(a, b);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;main中的a,b为    &quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot;\t&quot;</span> &lt;&lt; b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/images/12.png" alt="引用作为函数参数"></p>
<p>由运行结果我们可以看出，如果用引用作为函数的参数，在函数内部修改变量的值，也会改变函数外面的值。实际上my_swap函数的内部实现是, <code>int &amp;a = a；int &amp;b = b；</code>给变量a和b取了一个别名，只不过别名等于原名。他们指向同一块内存，所以在函数内部修改变量的值，函数外部的值也会改变。</p>
<h3 id="4、引用作函数返回值"><a href="#4、引用作函数返回值" class="headerlink" title="4、引用作函数返回值"></a>4、引用作函数返回值</h3><p>在C++中函数的返回值可以是一个引用，需要注意的是不可以返回局部变量的引用，这一点和不能返回局部变量的指针是一样的，因为局部变量是在栈区开辟的空间，而栈区的数据在函数结束后就自动释放了。此外，引用作为函数的返回值，这个函数还可以作为左值进行运算。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1、不能返回局部变量的引用</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>&amp; <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//2、函数引用可以作为左值</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>&amp; <span class="title">func2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span>&amp; ref = func();</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;不能返回局部变量的引用&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; ref &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; ref &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;函数引用可以作为左值&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">int</span> &amp;ref2 = func2();</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; ref2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	func2() = <span class="number">1000</span>;		<span class="comment">//将1000赋值给func2（）</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; ref2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; func2() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/images/13.png" alt="注意事项"></p>
<p>返回局部变量的引用，第一次可以成功访问是因为编译器做了一次保留，后面如果再访问就会出现乱码。函数可以作为左值是因为函数的返回值是一个a的引用，相当于int &amp;a = 1000；</p>
<h3 id="5、常量引用"><a href="#5、常量引用" class="headerlink" title="5、常量引用"></a>5、常量引用</h3><p>常量引用的主要用途是防止函数的参数被更改，此外引用必须指向一个合法的空间，不能直接让引用等于一个值。但是如果在引用前面加上一个const就可以直接赋值。</p>
<p><img src="/images/14.png" alt="引用必须指向一个合法空间"></p>
<p>这是因为加const后编译器自动在底层给我们做了一些操作，<code>int temp = 10;const int &amp;ref = temp;</code> 这样ref指向的就是temp这块空间了。</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>CPP提高</title>
    <url>/2020/10/07/CPP%E6%8F%90%E9%AB%98/</url>
    <content><![CDATA[<p>​        这篇文章主要介绍一下C++的一些注意事项和一些不太常见却很重要的用法</p>
<a id="more"></a>

<h3 id="void用法"><a href="#void用法" class="headerlink" title="void用法"></a>void用法</h3><p>&lt;&gt;</p>
<p>​        对于void很多小伙伴都没有太关注过这个关键字。事实上这个关键字还是非常有用的。它可以申明一个函数没有返回值。在C语言中，void还可以写在函数的参数中，表示该函数没有参数（当然不写的话也不会报错，只不过编译器会出一个警告）。在C++中就不必将void写入函数的参数中，因为C++底层已经帮用户做了这件事情。然而void最重要的用法是void *也就是void 指针。可以说void *是所有指针的祖先。这是因为任何类型的指针都可以赋值给void *。void * 出现在函数的参数中，说明该函数可以接受任何类型的指针。如果void *出现在函数开头，说明这个函数可以返回任何类型的指针。</p>
<p>​        典型的如内存操作函数memcpy和memset的函数原型分别为：<br>void * memcpy(void *dest, const void *src, size_t len);<br>void * memset ( void * buffer, int c, size_t num );</p>
<p>　　这样，任何类型的指针都可以传入memcpy和memset中，这也真实地体现了内存操作函数的意义，因为它操作的对象仅仅是一片内存，而不论这片内存是什么类型。</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>vs踩过的坑</title>
    <url>/2020/10/06/vs%E8%B8%A9%E8%BF%87%E7%9A%84%E5%9D%91/</url>
    <content><![CDATA[<p>​        相信很多小伙伴都用过visual studio这个编译器（下文简称vs）。这款编译器的大部分功能还是很强大的，而且与其它编译器的差别并不是很明显。vs的安全性特别高，代码除了一点点的小问题，编译器就会报错。接下来就谈一谈，我使用vs过程中踩过的一些坑。<a id="more"></a></p>
<h3 id="1、scanf-s"><a href="#1、scanf-s" class="headerlink" title="1、scanf_s"></a>1、scanf_s</h3><p>​        关于scanf函数，在很多编译器当中是可以正常使用的，但是在vs当中，它被认为是不安全函数。因为scanf函数在读取数据时不检查边界情况，这样就很懂依造成内存访问越界。vs提供了一个安全函数scanf_s(),这个函数比scanf函数多一个参数，就是你要输入的个数。在使用这个函数时，只有当要输入char【】，也就是字符数组时，才需要注意下面这些细节。</p>
<p>​        当你定义一个字符数组的长度为n时，你在输入的时候必需将你要输入的字符长度写入scanf_s的参数当中。而且，虽然你想输入n个字符，但是最多只能输入n-1个字符。因为scanf_s最后一个参数是缓冲区的大小，表示最多读取n-1个字符。下面给一些具体例子的截图。</p>
<p><img src="/images/1.png" alt="正确用法"></p>
<p><img src="/images/2.png" alt="输入的字符串长度大于n-1"></p>
<p><img src="/images/3.png" alt="没有n-1这个参数报错"></p>
<p>​        第一张图片是正确的运行结果，第二张是当你输入的字符长度大于n-1时，此时的编译器什么也不输出。第三张是没有n-1这个参数的，编译器直接报错。如果你用scanf_s输入其他类型的变量是，是不用加n这个变量的。</p>
<p>​        以上就是scan_s函数的一些坑。（第一次写博客，写得不好的地方请多包涵，如果读者有补充的可以回帖，喜欢的可以投喂一下哦！！）</p>
]]></content>
      <categories>
        <category>vs2019</category>
      </categories>
      <tags>
        <tag>vs2019</tag>
      </tags>
  </entry>
  <entry>
    <title>我的第一篇博客</title>
    <url>/2020/10/02/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<p>欢迎访问我的博客（希望自己以后越来越好）</p>
]]></content>
  </entry>
</search>
