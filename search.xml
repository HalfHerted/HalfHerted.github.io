<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[引用的用法及注意事项]]></title>
    <url>%2F2020%2F10%2F15%2F%E5%BC%95%E7%94%A8%E7%9A%84%E7%94%A8%E6%B3%95%E5%8F%8A%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%2F</url>
    
      <content type="text"><![CDATA[​ 这篇文章主要介绍一下C++中引用的一些用法和注意事项。 1、引用的作用​ 引用在C++中的作用就是给一个变量取一个别名，具体语法为：数据类型 + &amp; + 别名 = 原名。引用的本质其实是一个指针常量。 123456789101112131415#include&lt;iostream&gt;using namespace std;void test01()&#123; int a = 10; int&amp; b = a; //a 和 b的效果相同 cout &lt;&lt; a &lt;&lt; endl; cout &lt;&lt; b &lt;&lt; endl;&#125;int main()&#123; test01();&#125; 2、引用的注意事项​ 引用有两个注意需要注意的地方 1、引用必须初始化 由图可以看到，在未初始化时，vs提示了一个错误“引用变量类型‘b’初始化设定”，这就是提示我们没有给引用初始化。 2、引用初始化后不可改变123456789101112131415161718#include&lt;iostream&gt;using namespace std;void test01()&#123; int a = 10; int c = 100; int&amp; b = a; b = c; //这里是赋值操作，并不能改变b的指向 cout &lt;&lt; a &lt;&lt; endl; cout &lt;&lt; b &lt;&lt; endl;&#125;int main()&#123; test01(); system(&quot;pause&quot;);&#125; 由运行结果我们可以看出，虽然由一串代码 b=c，但这代码仅仅是赋值操作。前面我们说了，引用的本质是一个指针常量，在这里仅仅是让b所指向的内存空间（也就是a所在的内存位置）重新赋值为c（也就是100）。所以最后输出的a和b的值都为100。类似于下面代码 int a = 10;int *b = &amp;a;int c = 100;*b = c; 唯一不同的是*b的指向可以改变，而引用的指向不可以改变。 3、引用作函数的参数相信大多数小伙伴都知道函数参数的传递方式有两种，第一种是值传递，第二种是地址传递。下面我们先分别为值传递和地址传递写一段代码。 12345678910111213141516171819202122232425262728#include&lt;iostream&gt;using namespace std;//值传递void my_swap1(int a, int b)&#123; int temp = a; a = b; b = temp; cout &lt;&lt; &quot;my_swap1中的a,b为&quot; &lt;&lt; a &lt;&lt; &quot;\t&quot; &lt;&lt; b &lt;&lt; endl;&#125;void my_swap2(int* a, int* b)&#123; int temp = *a; *a = *b; *b = temp; cout &lt;&lt; &quot;my_swap2中的a,b为&quot; &lt;&lt; *a &lt;&lt; &quot;\t&quot; &lt;&lt; *b &lt;&lt; endl;&#125;int main()&#123; int a = 10, b = 20; my_swap1(a, b); cout &lt;&lt; &quot;main中的a,b为 &quot; &lt;&lt; a &lt;&lt; &quot;\t&quot; &lt;&lt; b &lt;&lt; endl; cout &lt;&lt; endl; my_swap1(a, b); cout &lt;&lt; &quot;main中的a,b为 &quot; &lt;&lt; a &lt;&lt; &quot;\t&quot; &lt;&lt; b &lt;&lt; endl; system(&quot;pause&quot;);&#125; 相信大家对上面两个已经非常熟悉了，这里我就不做过多的介绍了。下面我们来看一下引用作为函数参数的情况。 12345678910111213141516171819202122#include&lt;iostream&gt;using namespace std;void my_swap(int &amp;a, int &amp;b)&#123; int temp = a; a = b; b = temp; cout &lt;&lt; &quot;my_swap1中的a,b为&quot; &lt;&lt; a &lt;&lt; &quot;\t&quot; &lt;&lt; b &lt;&lt; endl;&#125;int main()&#123; int a = 10, b = 20; my_swap(a, b); cout &lt;&lt; &quot;main中的a,b为 &quot; &lt;&lt; a &lt;&lt; &quot;\t&quot; &lt;&lt; b &lt;&lt; endl; cout &lt;&lt; endl; system(&quot;pause&quot;);&#125; 由运行结果我们可以看出，如果用引用作为函数的参数，在函数内部修改变量的值，也会改变函数外面的值。实际上my_swap函数的内部实现是, int &amp;a = a；int &amp;b = b；给变量a和b取了一个别名，只不过别名等于原名。他们指向同一块内存，所以在函数内部修改变量的值，函数外部的值也会改变。 4、引用作函数返回值在C++中函数的返回值可以是一个引用，需要注意的是不可以返回局部变量的引用，这一点和不能返回局部变量的指针是一样的，因为局部变量是在栈区开辟的空间，而栈区的数据在函数结束后就自动释放了。此外，引用作为函数的返回值，这个函数还可以作为左值进行运算。 123456789101112131415161718192021222324252627282930313233343536#include&lt;iostream&gt;using namespace std;//1、不能返回局部变量的引用int&amp; func()&#123; int a = 10; return a;&#125;//2、函数引用可以作为左值int&amp; func2()&#123; static int a = 10; return a;&#125;int main()&#123; int&amp; ref = func(); cout &lt;&lt; &quot;不能返回局部变量的引用&quot; &lt;&lt; endl; cout &lt;&lt; ref &lt;&lt; endl; cout &lt;&lt; ref &lt;&lt; endl; cout &lt;&lt; endl; cout &lt;&lt; &quot;函数引用可以作为左值&quot; &lt;&lt; endl; int &amp;ref2 = func2(); cout &lt;&lt; ref2 &lt;&lt; endl; func2() = 1000; //将1000赋值给func2（） cout &lt;&lt; ref2 &lt;&lt; endl; cout &lt;&lt; func2() &lt;&lt; endl; system(&quot;pause&quot;);&#125; 返回局部变量的引用，第一次可以成功访问是因为编译器做了一次保留，后面如果再访问就会出现乱码。函数可以作为左值是因为函数的返回值是一个a的引用，相当于int &amp;a = 1000； 5、常量引用常量引用的主要用途是防止函数的参数被更改，此外引用必须指向一个合法的空间，不能直接让引用等于一个值。但是如果在引用前面加上一个const就可以直接赋值。 这是因为加const后编译器自动在底层给我们做了一些操作，int temp = 10;const int &amp;ref = temp; 这样ref指向的就是temp这块空间了。]]></content>
    
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[内存四区]]></title>
    <url>%2F2020%2F10%2F10%2F%E5%86%85%E5%AD%98%E5%9B%9B%E5%8C%BA%2F</url>
    
      <content type="text"><![CDATA[​ 这篇文章主要介绍的是程序内存的四个存储区域：代码区、全局区、栈区、堆区。 代码区​ 代码区，简单来说就是存放代码的一块区域，这块区域在程序运行前存在。其实代码区存放的代码时CPU执行的机器指令，也就是二进制字符串。 ​ 代码区有两个特点：共享性和只读性。 ​ 1、共享性：因为一个程序有可能被运行很多次，不可能每次运行前都要将代码保存一次，所以共享性是为了让程序能够高效的多次运行。 ​ 2、只读性：为了防止程序运行过程中被恶意修改代码，造成损失，所以代码区具有只读性，不能修改。 全局区​ 全局区也是在程序运行之前存在的一块区域。存放在全局区的数据主要有三类：全局变量、静态变量、常量。其中常量有可以细分为字符串常量和const修饰的变量，字符串常量存放在全局区。const修饰的变量又可以分为const修饰的全局变量和const修饰的局部变量。其中const修饰的全局变量存放在全局区，而const修饰的局部变量（局部常量）不存放在全局区。下面代码演示 12345678910111213141516171819202122232425262728293031323334#include&lt;iostream&gt;using namespace std;//全局变量int g_a = 10;int g_b = 100;//const修饰的全局变量const int c_g_a = 10;const int c_g_b = 100;int main()&#123; //静态变量 static int s_a = 100; static int s_b = 10; //const修饰的局部变量 const int c_l_a = 100; const int c_l_b = 10; //全局变量 cout &lt;&lt; &quot;全局变量g_a的地址为：&quot; &lt;&lt; &amp;g_a &lt;&lt; endl; cout &lt;&lt; &quot;全局变量g_b的地址为：&quot; &lt;&lt; &amp;g_b &lt;&lt; endl; //静态变量 cout &lt;&lt; &quot;静态变量s_a的地址为：&quot; &lt;&lt; &amp;s_a &lt;&lt; endl; cout &lt;&lt; &quot;静态变量s_a的地址为：&quot; &lt;&lt; &amp;s_a &lt;&lt; endl; //字符串常量 cout &lt;&lt; &quot;字符串常量的地址为：&quot; &lt;&lt; &amp;&quot;hello&quot; &lt;&lt; endl; //const修饰的全局变量 cout &lt;&lt; &quot;const修饰的全局变量的地址为：&quot; &lt;&lt; &amp;c_g_a &lt;&lt; endl; cout &lt;&lt; &quot;const修饰的全局变量的地址为：&quot; &lt;&lt; &amp;c_g_a &lt;&lt; endl; //const修饰的局部变量 cout &lt;&lt; &quot;const修饰的局部变量的地址为：&quot; &lt;&lt; &amp;c_l_a &lt;&lt; endl; cout &lt;&lt; &quot;const修饰的局部变量的地址为：&quot; &lt;&lt; &amp;c_l_a &lt;&lt; endl;&#125; 从运行结果可以看出全局变量、静态变量、字符串常量、以及const修饰的全局变量他们的内存位置靠得非常近，而const修饰得局部变量与他们靠得非常远。这也就说明了const修饰得局部变量与另外几个不在一个区域。 ​ 另外：全局区的数据在程序结束后由系统释放 栈区​ 栈区由编译器自动释放，存放在栈区的数据主要有函数的参数、和局部变量。尤其需要注意的是不能返回局部变量的地址，因为栈区的数据在程序结束后是由编译器自动释放，所以返回局部变量的地址是找不到你想找的那个数据的。 12345678910111213141516#include&lt;iostream&gt;using namespace std;int* test01()&#123; int a = 10; int* p = &amp;a; return p;&#125;int main()&#123; int* p = test01(); cout &lt;&lt; *p &lt;&lt; endl; //第一次成功访问到数据是因为编译器做了一次保留 cout &lt;&lt; *p &lt;&lt; endl; //第二次就访问不到该数据了&#125; 堆区​ 堆区的数据由程序员进行释放，当然如果程序员忘记释放，在程序运行结束后编译器也会帮你释放。一般在堆区开辟空间需要用到new关键字。 ​ 在上面的栈区说到不能返回局部变量的地址是因为局部变量存放在栈区，栈区的数据由编译器自动释放。那么我们把数据开辟到堆区呢？ 1234567891011121314151617#include&lt;iostream&gt;using namespace std;int* test02()&#123; int* p =new int (10); return p;&#125;int main()&#123; int* p = test02(); cout &lt;&lt; *p &lt;&lt; endl; cout &lt;&lt; *p &lt;&lt; endl; cout &lt;&lt; *p &lt;&lt; endl; cout &lt;&lt; *p &lt;&lt; endl;&#125; ​ 可以发现输出了四次仍然可以访问到数据。这是因为堆区的数据没有被释放，那么释放之后又会如何呢？ 123456789101112131415161718#include&lt;iostream&gt;using namespace std;int* test02()&#123; int* p =new int (10); return p;&#125;int main()&#123; int* p = test02(); cout &lt;&lt; *p &lt;&lt; endl; cout &lt;&lt; *p &lt;&lt; endl; free(p); cout &lt;&lt; *p &lt;&lt; endl; cout &lt;&lt; *p &lt;&lt; endl;&#125; ​ 可以看到，前两次是没有将数据释放掉是可以访问的，后面将数据释放掉之后，就访问不到该数据了。 ​ 以上就是我对内存四区的全部理解，如果有不足的地方请指正。如果觉得讲得还不错的话，可以投喂一下哦！！]]></content>
    
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CPP提高]]></title>
    <url>%2F2020%2F10%2F07%2FCPP%E6%8F%90%E9%AB%98%2F</url>
    
      <content type="text"><![CDATA[​ 这篇文章主要介绍一下C++的一些注意事项和一些不太常见却很重要的用法 void用法&lt;&gt; ​ 对于void很多小伙伴都没有太关注过这个关键字。事实上这个关键字还是非常有用的。它可以申明一个函数没有返回值。在C语言中，void还可以写在函数的参数中，表示该函数没有参数（当然不写的话也不会报错，只不过编译器会出一个警告）。在C++中就不必将void写入函数的参数中，因为C++底层已经帮用户做了这件事情。然而void最重要的用法是void *也就是void 指针。可以说void *是所有指针的祖先。这是因为任何类型的指针都可以赋值给void *。void * 出现在函数的参数中，说明该函数可以接受任何类型的指针。如果void *出现在函数开头，说明这个函数可以返回任何类型的指针。 ​ 典型的如内存操作函数memcpy和memset的函数原型分别为：void * memcpy(void *dest, const void *src, size_t len);void * memset ( void * buffer, int c, size_t num ); 这样，任何类型的指针都可以传入memcpy和memset中，这也真实地体现了内存操作函数的意义，因为它操作的对象仅仅是一片内存，而不论这片内存是什么类型。]]></content>
    
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vs踩过的坑]]></title>
    <url>%2F2020%2F10%2F06%2Fvs%E8%B8%A9%E8%BF%87%E7%9A%84%E5%9D%91%2F</url>
    
      <content type="text"><![CDATA[​ 相信很多小伙伴都用过visual studio这个编译器（下文简称vs）。这款编译器的大部分功能还是很强大的，而且与其它编译器的差别并不是很明显。vs的安全性特别高，代码除了一点点的小问题，编译器就会报错。接下来就谈一谈，我使用vs过程中踩过的一些坑。 1、scanf_s​ 关于scanf函数，在很多编译器当中是可以正常使用的，但是在vs当中，它被认为是不安全函数。因为scanf函数在读取数据时不检查边界情况，这样就很懂依造成内存访问越界。vs提供了一个安全函数scanf_s(),这个函数比scanf函数多一个参数，就是你要输入的个数。在使用这个函数时，只有当要输入char【】，也就是字符数组时，才需要注意下面这些细节。 ​ 当你定义一个字符数组的长度为n时，你在输入的时候必需将你要输入的字符长度写入scanf_s的参数当中。而且，虽然你想输入n个字符，但是最多只能输入n-1个字符。因为scanf_s最后一个参数是缓冲区的大小，表示最多读取n-1个字符。下面给一些具体例子的截图。 ​ 第一张图片是正确的运行结果，第二张是当你输入的字符长度大于n-1时，此时的编译器什么也不输出。第三张是没有n-1这个参数的，编译器直接报错。如果你用scanf_s输入其他类型的变量是，是不用加n这个变量的。 ​ 以上就是scan_s函数的一些坑。（第一次写博客，写得不好的地方请多包涵，如果读者有补充的可以回帖，喜欢的可以投喂一下哦！！）]]></content>
    
      <categories>
        <category>vs2019</category>
      </categories>
      <tags>
        <tag>vs2019</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我的第一篇博客]]></title>
    <url>%2F2020%2F10%2F02%2F%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%2F</url>
    
      <content type="text"><![CDATA[欢迎访问我的博客（希望自己以后越来越好）]]></content>
    
  </entry>
</search>
